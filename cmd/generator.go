package main

import (
    "bytes"
    "encoding/csv"
    "fmt"
    "io"
    "log"
    "os"
    "path/filepath"
    "gopkg.in/yaml.v2"
    "unicode"
)

type Row struct {
    Id      string
    Unknown string
    Index   string
    Offset  string
    Text    string
}

func UniqueId(id string, unknown string, index string) string {
    return fmt.Sprintf("%s-%s-%s", id, unknown, index)
}

func UniqueIdFromRow(row *Row) string {
    return UniqueId(row.Id, row.Unknown, row.Index)
}

type Section struct {
    Name       string
    QuestTypes []*QuestType
}

type QuestType struct {
    Name           string
    QuestUniqueIds []string
}

func main() {
    mappingFile, err := os.Open(filepath.Join("mapping.yml"))
    if err != nil {
        log.Fatal(err)
    }

    var mapping yaml.MapSlice

    err = yaml.NewDecoder(mappingFile).Decode(&mapping)
    if err != nil {
        log.Fatal(err)
    }
    mappingFile.Close()

    sections := []*Section{}

    for _, sectionValue := range mapping {
        section := &Section{
            Name:       sectionValue.Key.(string),
            QuestTypes: []*QuestType{},
        }
        sections = append(sections, section)

        if sectionValue.Value == nil {
            continue
        }

        for _, questTypeValue := range sectionValue.Value.(yaml.MapSlice) {
            questType := &QuestType{
                Name:           questTypeValue.Key.(string),
                QuestUniqueIds: []string{},
            }
            section.QuestTypes = append(section.QuestTypes, questType)

            for _, unuqueId := range questTypeValue.Value.([]interface{}) {
                questType.QuestUniqueIds = append(questType.QuestUniqueIds, unuqueId.(string))

            }
        }
    }

    questUniqueIds := []string{}

    for _, section := range sections {
        for _, questType := range section.QuestTypes {
            for _, questUniqueId := range questType.QuestUniqueIds {
                questUniqueIds = append(questUniqueIds, questUniqueId)
            }
        }
    }

    // @todo
    langs := []string{"en", "de", "es", "fr", "jp", "ru"}

    for _, lang := range langs {
        langFile, err := os.Open(filepath.Join("lang", lang+".lang.csv"))
        if err != nil {
            log.Fatal(err)
        }

        names, err := getTranslationFromCsv(langFile, questUniqueIds)
        langFile.Close()
        if err != nil {
            log.Fatal(err)
        }

        err = genTranslateFile(lang, sections, names)
        if err != nil {
            log.Fatal(err)
        }
    }

    log.Print("done...")

}

func rowFromRecord(record []string) *Row {
    return &Row{
        Id:      record[0],
        Unknown: record[1],
        Index:   record[2],
        Offset:  record[3],
        Text:    record[4],
    }
}

func getTranslationFromCsv(langFile *os.File, questUniqueIds []string) (map[string]string, error) {
    names := map[string]string{}

    for _, questUniqueId := range questUniqueIds {
        names[questUniqueId] = ""
    }

    csvFile := csv.NewReader(langFile)

    _, err := csvFile.Read()
    if err != nil {
        return names, err
    }

    for {
        record, err := csvFile.Read()
        if err == io.EOF {
            break
        }
        if err != nil {
            log.Fatal(err)
        }

        row := rowFromRecord(record)
        uniqueId := UniqueIdFromRow(row)

        _, ok := names[uniqueId]
        if ok {
            names[uniqueId] = row.Text
        }
    }

    return names, nil
}

func genTranslateFile(lang string, sections []*Section, names map[string]string) error {
    translationFile, err := os.Create(filepath.Join("output", lang+"_quests.lua"))
    if err != nil {
        return err
    }
    defer translationFile.Close()

    buf := bytes.NewBuffer(nil)

    buf.WriteString(`-- THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
-- L is a convenience table so we don't have to write ZO_CreateStringId a bunch of times
local L = {}`)

    for _, section := range sections {
        for _, questType := range section.QuestTypes {
            buf.WriteString(fmt.Sprintf("\n\n-- %s. %s", section.Name, questType.Name))

            for index, questUniqueId := range questType.QuestUniqueIds {
                name, ok := names[questUniqueId]
                if !ok {
                    return fmt.Errorf("no translation for " + questUniqueId)
                }
                buf.WriteString(fmt.Sprintf("\nL.SI_DQT_%s_%s_%02d = \"%s\"", constNameFromName(section.Name), constNameFromName(questType.Name), index+1, name))
            }
        }
    }

    if lang == "en" {
        buf.WriteString(`

for stringId, translation in pairs(L) do
    ZO_CreateStringId(stringId, translation)
end
`)
    } else {
        buf.WriteString(`

for stringId, translation in pairs(L) do
    SafeAddString(_G[stringId], translation, 0)
end
`)
    }

    translationFile.Write(buf.Bytes())

    return nil
}

func constNameFromName(str string) string {
    buf := bytes.NewBufferString("")

    wasUnderscore := false

    for _, r := range str {
        if r >= 'A' && r <= 'Z' {
            buf.WriteRune(r)
        } else if (r >= 'a' && r <= 'z') {
            buf.WriteRune(unicode.ToUpper(r))
            wasUnderscore = false
        } else {
            if !wasUnderscore {
                buf.WriteRune('_')
                wasUnderscore = true
            }
        }
    }

    return buf.String()
}
